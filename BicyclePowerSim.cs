/*
Bicycle Power Simulation

Calculate the power required to reach a given speed
and get the resulting speed by entering a power value

*/

using UnityEngine;
using System.Collections;

public class BicyclePowerSim : MonoBehaviour
{
    public bool useMPH = false;
   

    //Environmental  parameters 
    public float slopeGrade = 0.5f; //the slope %  ( 100 * rise / run or tangent of angle x 100)
    public float airDensity = 1.226f;


    //Bike and rider parameters
    // public float totalMass = 0; // mass of the rider + bike in kg 
    // public float totalMass; // we need this not anymore
   
    
    public float frontalArea = 0.25f;  //surface in m2
    public float drivetrainEffectiveness = 95; // Power loss due to friction is 5%
    public float coefficientOfRollingResistance = 0.004f; //dimensionless //0.005f
    public float dragCoef = 0.63f; //dimensionless 
    public float power { get; private set; }
    public float speed
    {
        get
        {
            if (currentVelocity <= 0) {
                return 0;
            }

            return useMPH ? currentVelocity / 0.44704f : currentVelocity * 3.6f;
        }
    }

    private float currentVelocity = 0; //the speed in m/s
    public float Fgravity { get; private set; }
    public float FrollingResitance { get; private set; }
    public float FaeroDrag { get; private set; }
    public float Fbrake { get; private set; }
    private float maxPower = 2500;
    private float brakeValue = 0;

    public float distanceTravelled = 0.001f;  //for distance

    Vector3 lastYPosition;
    Vector3 currentYPosition;
  

    public float totalClimb = 0;
    // public float distanceClimbed = 0; //for climb

    Vector3 lastPosition;

    public float weight;

    public CentralSensor centralSensor;
    public FitnessEquipmentDisplay fed;

    //for checking the slope only 0,5 seconds
    private float nextActionTime = 0.5f;
    public float period = 1.0f;

    public void Start()
    {
        lastPosition = transform.position;
        lastYPosition = transform.position;

        ProfileSessionManager.GetUserWeight();
        weight = ProfileSessionManager.curPlayerWeight;

        if (weight == 0) {
            weight = 80;            
        }

        centralSensor = GameObject.Find("DemoUI").GetComponent<CentralSensor>();
        //centralSensor = GameObject.FindWithTag("USERUI").GetComponent<CentralSensor>();
        fed = GameObject.Find("FitnessEquipmentDisplay").GetComponent<FitnessEquipmentDisplay>();


       /* if (fed.connected == true)
        {
            InvokeRepeating("CheckSlopeGrade", 5.0f, 0.5f);
            
        }
        */
    }

    public void FixedUpdate() //FixedUpdate()
    {

       
        if (centralSensor == null)
        {
            centralSensor = GameObject.Find("DemoUI").GetComponent<CentralSensor>();
        }

        if (fed == null)
        {
            GameObject.Find("FitnessEquipmentDisplay").GetComponent<FitnessEquipmentDisplay>();
        }

        if (speed > 0.1)
        {
            distanceTravelled += Vector3.Distance(transform.position, lastPosition);
            lastPosition = transform.position;
        }
        //How many heightMeter we have climbed
        currentYPosition = transform.position;

        if (currentYPosition.y > lastYPosition.y)
            totalClimb += currentYPosition.y - lastYPosition.y;

        lastYPosition = currentYPosition;

        //for checking the slope only 0,5 seconds
        if (Time.time > nextActionTime)
        {
            nextActionTime += period;
            CheckSlopeGrade();
            //
        }

    }

    void CheckSlopeGrade()
    {
        if (fed.connected == true)

        {
            slopeGrade = GameObject.FindWithTag("Player").GetComponent<BicyclePowerSim>().slopeGrade;
            GameObject.Find("FitnessEquipmentDisplay").GetComponent<FitnessEquipmentDisplay>().SetTrainerSlope(Mathf.RoundToInt(slopeGrade));
        }
        if (fed.connected == false)
        {
            return;
        }
        //return;
    }

    //Get the required power to reach a given speed in km/s or mph, returns the rider leg power needed
    public float GetPowerforSpeed(float speedInput)
    {
        //weight = totalMass;
       // totalMass = weight;

        float resistingForce = CalculateResistingForces(useMPH ? speedInput * 0.44704f : speedInput / 3.6f);
        float acceleration = resistingForce / weight;
        float power = ((acceleration / weight) + resistingForce);
        return Mathf.Clamp(power, 0, maxPower);
    }



    //Move the bike by entering the power generated by the rider; returns the bike current velocity in km/s or mph (public bool useMPH = false)
    public float SetPower(float powerInput, bool instant = false)
    {
        powerInput = centralSensor.GetPower();
        power = powerInput;

        //  powerInput = GameObject.Find("FitnessEquipmentDisplay").GetComponent<FitnessEquipmentDisplay>().instantaneousPower;
        //   powerInput = GameObject.Find("FitnessEquipmentDisplay").GetComponent<FitnessEquipmentDisplay>().instantaneousPower;
        float resistingForce = CalculateResistingForces(currentVelocity);
        if (float.IsNaN(resistingForce)) {
            resistingForce = 0;
        }
        
        float wheelPower = drivetrainEffectiveness * powerInput / 100f;
        float totalForce = wheelPower - (resistingForce);

        if (brakeValue > 0) {
            float brakeForce = weight * currentVelocity;
            Fbrake = -brakeForce * brakeValue;
            totalForce = Fbrake;
        } else {
            Fbrake = 0;
        }


        float acceleration = totalForce / weight;
        if (instant) {
            currentVelocity += acceleration;
        } else {
            currentVelocity += (acceleration * Time.deltaTime);
        }


        return useMPH ? currentVelocity / 0.44704f : currentVelocity * 3.6f;
    }

    //how much brake force is apply; 0 for no brake,  1 for full brake force
    public void SetBrakeForce(float brakeValue)
    {
        this.brakeValue = Mathf.Clamp01(brakeValue);
    }

    //Compute the the 3 forces acting on the bike ( gravity, rolling resistance and aerodynamic drag)
    private float CalculateResistingForces(float velocity)
    {
        Fgravity = velocity * 9.8067f * 1 * Mathf.Sin(Mathf.Atan(slopeGrade / 100f)) * weight;
        FrollingResitance = velocity * 9.8067f * 1 * Mathf.Cos(Mathf.Atan(slopeGrade / 100f)) * weight * coefficientOfRollingResistance;
        FaeroDrag = velocity * 0.5f * dragCoef * frontalArea * airDensity * (velocity * velocity);
      //  Debug.Log("CoeffRolling" + coefficientOfRollingResistance);

        return Fgravity + FrollingResitance + FaeroDrag;



    }
   
}
